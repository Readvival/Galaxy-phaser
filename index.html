<!doctype html>
<html>
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"> 
    <link rel="shortcut icon" href="favicon.png" type="image/x-icon">
    <title>GALAXY</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body> 
<script src="howler.min.js"></script>
<script src="phaser.min.js"></script>
<script>
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    input: {
        activePointers: 5
    },
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    pixelArt: true,
    scene: { preload, create, update }
};

let bg;
let title;
let startButton;
let player;
let enemyGroup;
let enemySpawnTimer;
let playerHp = 100;
let plasmaGroup;
let plasmaGroup2;
let shootTimer;
let canSpawnEnemies = true;
let healthGroup, energyGroup, powerupGroup;
let shieldGroup;
let playerExp = 0;
let leftTurret = null;
let rightTurret = null;
let asteroidGroup;


let hpBar, expBar;
let heartBox, energyBox;

let enemyKillCount = 0;
let nextDropKillCount;
let bgMusic;

let turretHp = 120;

function preload(){
    //background
    this.load.image("background","assets/background.png");
    
    //player 
    this.load.image("player01","assets/playerBlue.png")
    
    //weapon Shoot
    this.load.image("smallPlasma","assets/smallPlasma.png");
    this.load.image("mediumPlasma","assets/mediumPlasma.png");
    this.load.image("largePlasma","assets/largePlasma.png");
    
    //enemy bullets
    this.load.image("enemyBullet","assets/enemyBullet.png");
    
    //Enemy
    this.load.image("enemy01","assets/enemy01.png");
    this.load.image("enemy02","assets/enemy02.png");
    this.load.image("enemy03","assets/enemy03.png");
    this.load.image("enemy04","assets/enemy04.png");
    //asteriods
    this.load.image("asteriod01","assets/asteriod01.png");
    this.load.image("asteriod02","assets/asteriod02.png");
    this.load.image("asteriod03","assets/asteriod03.png");
    this.load.image("asteriod04","assets/asteriod04.png");
    //health items
    this.load.image("healthItem","assets/healthItem.png");
    //energy items
    this.load.image("energyItem","assets/energyItem.png");
    //powerups items
    this.load.image("powerupItem","assets/powerupItem.png");
    //shield
    this.load.image("shieldItem","assets/shieldItem.png");
    //turrets 
    this.load.image("turret01","assets/turret01.png");
    //shield effects
    this.load.image("shieldEffect","assets/shieldEffect.png");
    //turret bullet
    this.load.image("turretBullet","assets/turretBullet.png");
        //ui for heart and energy
    this.load.image("energyBox","assets/energyBox.png");
    this.load.image("heartBox","assets/heartBox.png");
}

function create(){
    
bg = this.add.tileSprite(0, 0, this.sys.game.config.width, this.sys.game.config.height, 'background').setOrigin(0, 0);
    resizeBackground.call(this);

    // Adjust when screen resizes or phone rotates
    this.scale.on('resize', (gameSize) => {
        resizeBackground.call(this, gameSize);
    });
    
   title = this.add.text(this.scale.width / 2,200,"Galaxy Adventure",{fontSize: "32px", color: "#fff"}).setOrigin(0.5)
    
 startButton = this.add.text(this.scale.width / 2,350,"Start",{ fontSize: "25px" ,color: "#fff"}).setInteractive().setOrigin(0.5)
    startButton.on("pointerdown", () => startGame.call(this))
    
    
    bgMusic = new Howl({
  src: ['assets/backgroundMusic.mp3'], // make sure this file is in the same folder
  loop: true,
  volume: 0.4 // optional: adjust volume (0.0 to 1.0)
});


    
    
}

function resizeBackground(gameSize) {
    const width = gameSize ? gameSize.width : this.sys.game.config.width;
    const height = gameSize ? gameSize.height : this.sys.game.config.height;

    bg.displayWidth = width;
    bg.displayHeight = height;
}

function startGame() {
    startButton.destroy();
    title.destroy();


playerHp = 100;
  playerExp = 0;
  rightTurret = null;
  leftTurret = null;


energyBox = this.add.image(77,55,"energyBox").setDisplaySize(90,70).setScrollFactor(0)
    heartBox = this.add.image(78,30,"heartBox").setDisplaySize(90,70).setScrollFactor(0)
  
hpBar = this.add.rectangle(60, 30, 52, 10, 0xff0000).setOrigin(0, 0.5).setScrollFactor(0);
    expBar = this.add.rectangle(60, 55, 0, 10, 0x0000ff).setOrigin(0, 0.5).setScrollFactor(0);
    
    heartBox.setDepth(12);
   energyBox.setDepth(12);
    hpBar.setDepth(11);
    expBar.setDepth(11);

    bgMusic.play();
    
  nextDropKillCount = Phaser.Math.Between(2, 1); // first threshold

    player = this.physics.add.image(this.scale.width / 2, 480, "player01");
    player.setInteractive({ draggable: true });
    this.input.setDraggable(player);
    player.setCollideWorldBounds(true);

    // Create a group for plasma bullets
    plasmaGroup = this.physics.add.group();
    plasmaGroup2 = this.physics.add.group();
    
    enemyBulletGroup = this.physics.add.group();
    
    
    healthGroup = this.physics.add.group();
    energyGroup = this.physics.add.group();
    powerupGroup = this.physics.add.group();
    shieldGroup = this.physics.add.group();
    
    asteroidGroup = this.physics.add.group();
    
    enemyGroup = this.physics.add.group();
    
    // Auto shoot plasma every 300ms
    shootTimer = this.time.addEvent({
        delay: 300,
        callback: shootPlasma,
        callbackScope: this,
        loop: true
    });
    
    // Enemy shoots every 1.5 seconds
this.time.addEvent({
    delay: 1500,
    callback: enemyShoot,
    callbackScope: this,
    loop: true
});

    this.input.on('drag', (pointer, gameObject, dragX, dragY) => {
        const clampedX = Phaser.Math.Clamp(dragX, player.displayWidth / 2, this.sys.game.config.width - player.displayWidth / 2);
        const clampedY = Phaser.Math.Clamp(dragY, player.displayHeight / 2, this.sys.game.config.height - player.displayHeight / 2);

        gameObject.x = clampedX;
        gameObject.y = clampedY;
    });
    
    
    scheduleEnemySpawn.call(this);
    scheduleAsteroidSpawn.call(this);

    this.physics.add.overlap(plasmaGroup, enemyGroup, plasmaHitsEnemy, null, this);
    this.physics.add.overlap(plasmaGroup2, enemyGroup, mediumPlasmahitEnemy, null, this);
    this.physics.add.overlap(player, enemyBulletGroup, enemyBulletHitsPlayer, null, this);
    
    
    this.physics.add.overlap(player, asteroidGroup,asteriodHitPlayer, null, this);
    
    this.physics.add.overlap(player, healthGroup, collectItem, null, this);
    this.physics.add.overlap(player, energyGroup, collectItem, null, this);
    this.physics.add.overlap(player, powerupGroup, collectItem, null, this);

}



// Function to shoot plasma bullet
function shootPlasma() {
    if (!player) return;

    if (playerExp < 150) {
        // Single small plasma (center)
        const plasma = plasmaGroup.create(player.x, player.y - player.displayHeight / 2, 'smallPlasma');
        plasma.setVelocityY(-300);
        plasma.setCollideWorldBounds(false);
        plasma.setDepth(1);
        plasma.setScale(0.5);
        plasma.checkWorldBounds = true;
        plasma.outOfBoundsKill = true;
    } else {
        // Double shot: slightly apart but still centered
        const offset = 5; // distance between left/right shot

        // Left small plasma
        const plasma = plasmaGroup.create(player.x - offset, player.y - player.displayHeight / 2, 'smallPlasma');
        plasma.setVelocityY(-300);
        plasma.setCollideWorldBounds(false);
        plasma.setDepth(1);
        plasma.setScale(0.5);
        plasma.checkWorldBounds = true;
        plasma.outOfBoundsKill = true;

        // Right medium plasma
        const mediumPlasma = plasmaGroup2.create(player.x + offset, player.y - player.displayHeight / 2, 'mediumPlasma');
        mediumPlasma.setVelocityY(-350); // slightly faster
        mediumPlasma.setCollideWorldBounds(false);
        mediumPlasma.setDepth(1);
        mediumPlasma.setScale(0.7);
        mediumPlasma.checkWorldBounds = true;
        mediumPlasma.outOfBoundsKill = true;
    }
}

function enemyShoot() {
    if (!enemyGroup) return;

    enemyGroup.children.each(enemy => {
        if (!enemy.active) return;

        // Create a bullet at enemy position
        const bullet = enemyBulletGroup.create(enemy.x, enemy.y + enemy.displayHeight / 2, 'enemyBullet');
        
        bullet.setVelocityY(200); // move bullet downward at speed 200
        bullet.setCollideWorldBounds(false);
        bullet.setDepth(1);
        
        bullet.setScale(0.8);

        // Destroy bullet when out of screen
        bullet.checkWorldBounds = true;
        bullet.outOfBoundsKill = true;
    });
}


function scheduleEnemySpawn() {
    const delay = Phaser.Math.Between(4000, 6000);  // 4 to 6 seconds random delay
    enemySpawnTimer = this.time.addEvent({
        delay: delay,
        callback: spawnEnemies,
        callbackScope: this,
        loop: false
    });
}

function spawnEnemies() {
    if (!canSpawnEnemies) return;
    canSpawnEnemies = false;  // Prevent multiple spawns until current wave cleared

    const count = Phaser.Math.Between(2, 5);
    const enemyTextures = ["enemy01", "enemy02", "enemy03", "enemy04"];

    for(let i = 0; i < count; i++) {
        const x = Phaser.Math.Between(50, this.sys.game.config.width - 50);
        const y = Phaser.Math.Between(50, 150);
        const texture = Phaser.Utils.Array.GetRandom(enemyTextures);

        let enemy = enemyGroup.create(x, y, texture);

        const speedX = Phaser.Math.Between(50, 150);
        enemy.setVelocityX(Phaser.Math.Between(0, 1) ? speedX : -speedX);
        enemy.setCollideWorldBounds(true);
        enemy.setBounce(1, 0);
        enemy.hp = Phaser.Math.Between(10, 40);
    }
}


function plasmaHitsEnemy(plasma, enemy) {
    plasma.destroy();
    enemy.hp -= 2;

    if (enemy.hp <= 0) {
        enemy.destroy();
        //givePlayerShield.call(this);
        enemyKillCount++;

        if (enemyKillCount >= nextDropKillCount) {
            spawnRandomItem.call(this, enemy.x, enemy.y);
            enemyKillCount = 0;
            nextDropKillCount = Phaser.Math.Between(3, 5);
        }
    }
}

function mediumPlasmahitEnemy(mediumPlasma, enemy) {
    mediumPlasma.destroy();
    enemy.hp -= 7;

    if (enemy.hp <= 0) {
        enemy.destroy();
        enemyKillCount++;

        if (enemyKillCount >= nextDropKillCount) {
            spawnRandomItem.call(this, enemy.x, enemy.y);
            enemyKillCount = 0;
            nextDropKillCount = Phaser.Math.Between(3, 5);
        }
    }
}

function asteriodHitPlayer(player , asteriod){
    asteriod.destroy();
    playerHp -= Phaser.Math.Between(10,15);
    updateBars()
        console.log("Player HP:", playerHp);
    if (playerHp <= 0){
    player.destroy();
            this.scene.restart();
}
}


function enemyBulletHitsTurret(turret, bullet) {
    
    bullet.destroy();
    turretHp -= 4; // fixed damage
    console.log(`${turret.side} turret HP:`, turretHp);

    if (turretHp <= 0) {
        console.log(`${turret.side} turret destroyed!`);
        turret.destroy();

        if (turret.side === 'left') {
            leftTurret = null;
        } else if (turret.side === 'right') {
            rightTurret = null;
        }
    }
}

function spawnRandomItem(x, y) {
    const rand = Math.random();

    if (rand < 0.2) { 
        // 50% health
        const health = healthGroup.create(x, y, 'healthItem');
        health.setScale(0.8);
        health.setInteractive();
        health.itemType = 'health';
        health.healAmount = Phaser.Math.Between(10, 25);
        health.setVelocity(Phaser.Math.Between(-50, 50), Phaser.Math.Between(50, 50));
    } else if (rand < 0.8) {
        // 30% energy
        const energy = energyGroup.create(x, y, 'energyItem');
        energy.setScale(0.8);
        energy.setInteractive();
        energy.itemType = 'energy';
        energy.expAmount = Phaser.Math.Between(10, 40);
        energy.setVelocity(Phaser.Math.Between(-50, 50), Phaser.Math.Between(50, 50));
    } else if (rand < 0.6){
        const shield = shieldGroup.create(x,y, "shieldItem");
        shield.setScale(0.8);
        shield.setInteractive();
        shield.itemType = 'shield';
        shield.expAmount = Phaser.Math.Between(10, 40);
        shield.setVelocity(Phaser.Math.Between(-50, 50), Phaser.Math.Between(50, 50));
    } else {
        // 20% powerup
        const powerup = powerupGroup.create(x, y, 'powerupItem');
        powerup.setScale(0.8);
        powerup.setInteractive();
        powerup.itemType = 'powerup';
        powerup.setVelocity(Phaser.Math.Between(-50, 50), Phaser.Math.Between(50, 50));
    }
}

function collectItem(player, item) {
    if (item.itemType === 'health') {
        playerHp = Math.min(playerHp + item.healAmount, 100);
        updateBars()
        console.log(`Healed by ${item.healAmount}, HP: ${playerHp}`);
    } else if (item.itemType === 'energy') {
        playerExp += item.expAmount;
        updateBars()
        console.log(`Gained ${item.expAmount}% EXP, total EXP: ${playerExp}`);
    } else if (item.itemType === 'powerup') {
        addTurret.call(this);
        console.log('Powerup: Turret added');
    } else if (item.itemType === 'shield'){
    givePlayerShield.call(this);
}

    item.destroy();
}

function enemyBulletHitsPlayer(player, bullet) {
    bullet.disableBody(true, true);  // disable and hide the bullet only
    playerHp -= 2;
    console.log("Player HP:", playerHp);
    updateBars()
    if (playerHp <= 0) {
        player.destroy();
        alert("Game Over!");
        this.scene.restart();
    }
}


function asteriodhitsTurret(turret, asteriod){
    asteriod.destroy();
    
    turretHp -= Phase.Math.Between(15,25);
    
    if (turretHp <= 0){
    turret.destroy();
    
     if (turret.side === 'left') {
            leftTurret = null;
        } else if (turret.side === 'right') {
            rightTurret = null;
        }
    
}

}

function addTurret() {
    if (!leftTurret) {
        leftTurret = this.physics.add.image(player.x - 40, player.y, 'turret01');
        leftTurret.side = 'left';
        leftTurret.setScale(0.6);
        leftTurret.setDepth(1);
        leftTurret.lastShot = 0;
        
            this.physics.add.overlap(leftTurret, enemyBulletGroup, enemyBulletHitsTurret, null, this);
                this.physics.add.overlap(leftTurret, asteroidGroup, asteriodhitsTurret, null, this);
            
        
    } else if (!rightTurret) {
        rightTurret = this.physics.add.image(player.x + 40, player.y, 'turret01');
        rightTurret.side = 'right';
        rightTurret.setScale(0.6);
        rightTurret.setDepth(1);
        rightTurret.lastShot = 0;
        
            this.physics.add.overlap(rightTurret, enemyBulletGroup, enemyBulletHitsTurret, null, this);
                 this.physics.add.overlap(rightTurret, asteroidGroup, asteriodhitsTurret, null, this);
    }
}

function givePlayerShield() {
    // Shield properties
    player.shieldHP = 150;

    // Create shield sprite if it doesn't exist yet
       const shieldSprite = this.add.image(player.x,player.y, 'shieldEffect')
            .setScale(1.4)
            .setAlpha(0.7)
            .setDepth(2); // above player
        shieldSprite.setOrigin(0.5, 0.5);
    

    // Make sure it's visible and follows player
    shieldSprite.setVisible(true);

    // Follow player position every frame
    this.events.on('update', () => {
        if (shieldSprite.visible) {
            shieldSprite.x = player.x;
            shieldSprite.y = player.y - 10;
        }
    });

    // Remove shield after 30 seconds
    this.time.delayedCall(30000, () => {
        removePlayerShield();
    });
}

function removePlayerShield() {
    if (shieldSprite) {
        shieldSprite.setVisible(false);
    }
    player.shieldHP = 0;
}

function shootTurretPlasma(turret) {
    if (!plasmaGroup) return;

    const plasma = plasmaGroup.create(turret.x, turret.y - turret.displayHeight / 2, 'turretBullet');
    plasma.setVelocityY(-300);
    plasma.setScale(0.5);
    plasma.setDepth(1);

    plasma.checkWorldBounds = true;
    plasma.outOfBoundsKill = true;
}


function updateBars() {
    const hpPercent = Phaser.Math.Clamp(playerHp / 100, 0, 1);
    const expPercent = Phaser.Math.Clamp(playerExp / 150, 0, 1);

    hpBar.width = 40 * hpPercent;
    expBar.width = 40 * expPercent;
}




// Scene method
function spawnAsteroids() {
    const asteroidTextures = ["asteriod01", "asteriod02", "asteriod03", "asteriod04"];
    const count = Phaser.Math.Between(1, 2);
    for (let i = 0; i < count; i++) {
        const textureKey = Phaser.Utils.Array.GetRandom(asteroidTextures);
        const x = Phaser.Math.Between(50, this.sys.game.config.width - 50);
        const y = -50;
        const asteroid = asteroidGroup.create(x, y, textureKey);
        asteroid.setScale(Phaser.Math.FloatBetween(0.5, 1));
        asteroid.setVelocity(
            Phaser.Math.Between(-50, 50), 
            Phaser.Math.Between(100, 200)
        );
        asteroid.setAngularVelocity(Phaser.Math.Between(-50, 50));
    }
}

function scheduleAsteroidSpawn() {
    const delay = Phaser.Math.Between(10000, 35000); // 10â€“35s
    this.time.delayedCall(delay, () => {
        spawnAsteroids.call(this);
        scheduleAsteroidSpawn.call(this); // loop
    });
}



function update() { 
    if (playerHp <= 0) return;
        bg.tilePositionY -= 2;  
    
    if (plasmaGroup){
    
    // Remove plasma bullets that go off-screen (extra safety)
    plasmaGroup.children.each(plasma => {
        if (plasma.y < 0) {
            plasma.destroy();
        }
    });
    }
    
    if (plasmaGroup2){
    
    // Remove plasma bullets that go off-screen (extra safety)
    plasmaGroup2.children.each(plasma2 => {
        if (plasma2.y < 0) {
            plasma2.destroy();
        }
    });
    }
    
      if (enemyGroup){
    if (enemyGroup.countActive(true) === 0) {
        // All enemies dead, allow spawn new wave
        canSpawnEnemies = true;
        scheduleEnemySpawn.call(this);
    }
    
    
    if (enemyBulletGroup){
    enemyBulletGroup.children.each(bullet => {
        if (bullet.y > this.sys.game.config.height) {
            bullet.destroy();
        }
    });
}
}
    
    
    const timeNow = this.time.now;

if (leftTurret) {
    leftTurret.x = player.x - 40;
    leftTurret.y = player.y;

    if (timeNow - leftTurret.lastShot > 1000) { // shoot every 1 sec
        shootTurretPlasma.call(this, leftTurret);
        leftTurret.lastShot = timeNow;
    }
}

if (rightTurret) {
    rightTurret.x = player.x + 40;
    rightTurret.y = player.y;

    if (timeNow - rightTurret.lastShot > 1000) {
        shootTurretPlasma.call(this, rightTurret);
        rightTurret.lastShot = timeNow;
    }
}
    
    
}

new Phaser.Game(config);
</script>
</body>
</html>